# Servizi Sicuri

[Return](./README.md)

---

# Indice

- [Servizi Sicuri](#servizi-sicuri)
- [Indice](#indice)
  - [Introduzione](#introduzione)
  - [Timestamping - Marcatura Temporale](#timestamping---marcatura-temporale)
  - [Kerberos](#kerberos)


## Introduzione

I servizi sicuri possono essere implementati a livello di applicazione, trasporto o rete.
I principali a livello di applicazione sono:
- **Kerberos**
- **PGP**
- **TSS**
A livello di trasporto:
- **SSL**
- **TLS**
A livello di rete:
- **IPSec**

## Timestamping - Marcatura Temporale

Un documento ha validità leegale se è attestata in maniera univoca la data e l'ora in cui è stato firmato.

Esistono due sistemi di riferimento internazionali per il calcolo del tempo: **TAI (Tempo Atomico Internazionale)** e **UTC (Tempo Universale Coordinato)**. In ogni caso, per il timestamping si ricorre sempre a una terza parte fidata.

Una società che offre un servizio di timestamping deve garantire:
- Tempo della marca non deve essere falso
- Tramite una marchatura deve essere possibile individuare un documento, un istante e un autore.
- Ogni modifica deve essere rilevabile in modo da evitare che la marcatura possa essere riutilizzata.
- Deve essere possibile marcare documenti riservati mantendendo la riservatezza.
- Chiunque deve poter marcare e validare la marca di un documento.

I passaggi per il timestamping sono:
1. Un entità $A$ produce un messaggio $m$ che vuole firmare.
2. Concatena $m$ con il suo identificativo e ne fa l'hash per richiedere la marca temporale.
3. A $H(m||A)$ viene concatenata la marcatura temporale $T$
4. Il messaggio viene firmato dall'entità di certificazione con la sua chiave $S_{TSS}$ in modo che la marcatura sia non ripudiabile.
5. $A$ concatena la marcatura al messaggio $m$, ne fa l'hash e lo firma con la sua chiave $S_A$.

## Kerberos

Kerberos è un protoccollo di autenticazione che offre funzionalità di **Single Sign-On (SSO)**, consentendo agli utenti di accedere a più servizi senza dover reinserire le credenziali ogni volta. Utilizza soltanto funzioni di crittografia simmetrica, quindi è più performante ma meno scalabile. 

Può essere implementato in tre modalità:
- **Naive**:
  - il client fa una richiesta al server di autenticazione ($ID_c||P_c||ID_s$ id cliente, password cliente, id servzio).
  - il server risponde con un ticket di autenticazione ($Ticket=E_{K_S}[ID_c, AD_c, ID_s)]$) $K_S$ la conoscono solo il server e AS.
  - il client invia al servzio il messaggio $ID_c||Ticket$
- **V.2**: accediamo ad un servizio, serve introdurre la sessione. Disaccoppia Autenticazione ed emissione del ticket (Ticket Garant Server)
  - **Login:**
    - il cliente chiede a AS $ID_c||ID_{TGS}
    - AS risponde con $E_{KC}[Tikcet_{TGS}]$ $KC$ è chiave cliente-AS sfida e risposta cifrano con simmetrica.

Il ticket è $Ticket_{TGS}=E_{K_{TGS}}[ID_c||AD_c||ID_TGS||TimeStamp||\Delta T]$ con $\Delta T$ tempo di validità del ticket.

  - **Richiesta Servizio:**
    - Cliente chiede al TGS $ID_c||ID_{serv}||Ticket_{TGS}$
    - TGS risponde con $Ticket_{serv} = E_{K_{serv}}[ID_c||AD_c||ID_{serv}||TS_2||\Delta T_2]$

Per ogni sessione il cliente comunica con il servizio tramite $ID_c||Ticket_{serv}$

Non si ha la certezza che chi manda il ticket sia davvero il cliente, quindi si usa un nonce per evitare replay attack.

